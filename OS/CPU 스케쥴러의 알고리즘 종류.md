# CPU 스케쥴러의 알고리즘 종류



## FCFS - First Come First Served

간단하게 먼저온 순으로 진행해 주는 것입니다. Non preemptive라서 현재 진행중인 프로세스를 종료할 수단이 없습니다.

작업시간이 긴 프로세스로 인해 전체 OS가 느려지는 현상(호위 효과)이 일어날 수 있습니다.


## SJF - Shortest Job First

말 그대로 현재 시점에서 짧은 일을 먼저 처리하는 것입니다. 이 중에서도 Preemptive, Non preemptive가 존재합니다. Non preemptive의 경우에는 현재 실행하는 프로세스를 종료하지 않으며 Preemptive의 경우에는 현재 사용하는 프로세스보다 새 프로세스의 시간이 더 짧으면 교체하게 됩니다.



> **어떻게 프로세스의 시간을 알 수 있을까?**

프로세스를 실행하지 않고 시간을 정확히 알 수 없으니 '예측'을 하게 됩니다. 이 예측은 이전 프로세스의 '예상 수행시간'과 '실제 수행시간'을 기반으로 예측하게 됩니다.

- (N번째의 CPU 사용 예측치) = (적응속도) \* (N-1 프로세스의 실제 시간) + (1 - 적응속도) \* (N-1 프로세스 예측 시간)
  - 여기서 적응 속도는 0~1의 값을 가지고 0이 될수록 이전 예측에 좀 더 가중치를 주겠다는 이야기입니다.



## Priority - 우선순위 스케쥴링

각 프로세스에 우선순위를 부여하고 이 우선순위가 높을수록 먼저 CPU에 할당해 줍니다. 위 SJF의 경우에는 우선순위 스케쥴링의 일종으로 짧은 시간이라 예측된 프로세스에 우선도를 주는 형식입니다.

문제점은 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스가 계속 들어온다면 계속 실행되지 못할 수도 있습니다. 이걸 기아(Starvation)문제라고 합니다. 이를 해결하기 위해서는 aging 기법을 활용해 시간이 흐를 때 우선순위를 높여줘야 합니다.



## RR - Round Robin

일전 시간을 정한 뒤 이 시간이 지나면 **프로세스 완료 여부와 관계 없이 종료하고 다른 프로세스로 교체**하는 것입니다.  만일 시간 단위가 q 라고 하고 N개의 프로세스가 있다고 하면 각 프로세스가 (N-1)q보다 기다리는 경우는 없습니다.

시간 단위가 너무 길면 FCFS와 같아지고, 너무 짧으면 컨텍스트 스위칭이 빈번해지므로 조절이 필요합니다. 

## SRTF(Shortest Remaining Time First)

특징
- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 선점형 (Preemptive) 스케줄링
- 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.

문제점
- starvation
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.



## 다단계 큐 스케줄링
우선순위별로 준비 큐를 여러 개 사용하는 선점형 알고리즘입니다. 큐마다 다른 스케줄링 알고리즘과 타임 슬라이스를 지정할 수 있습니다.

우선순위를 구분하여 실행하기에 용이합니다.
다만, 높은 우선순위 큐부터 실행되기 때문에 기아현상이 나타날 수 있습니다.


## 다단계 피드백 큐
다단계 피드백 큐에서는 프로세스가 큐 사이를 오갈 수 있습니다. 

처음에는 최상위 큐에 진입하여 타임 슬라이스만큼 실행합니다. CPU 시간을 너무 많이 소모하면 다음 큐로 내려갑니다. 따라서 자연스럽게 오래 걸리는 **CPU 집중 프로세스**는 우선순위가 낮은 큐에서, **입출력 집중 프로세스**는 우선순위가 높은 큐에서 실행이 끝나게 됩니다.

낮은 큐에서 너무 오래 머무른 큐의 기아현상을 방지하기 위해 에이징 기법을 사용하여 높은 큐로 다시 이동시켜줍니다.
