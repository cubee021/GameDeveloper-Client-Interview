# 가상 메모리 - Virtual Memory

가상 메모리 기법은 실제 메모리(RAM) 크기와 관계없이 메모리를 사용할 수 있도록 하는 기법입니다. 프로그램의 현재 실행에 필요한 부분만 메모리에 올라가고 나머지는 보조 기억장치(HDD, SSD 등)에 올려두고 사용하는 것입니다.

이런 과정을 위해 MMU(Memory Management Unit)이라는 장치가 필요하며 이 장치를 통해 논리 주소를 물리 주소로 변환할 수 있게 됩니다. 현대 CPU는 다 MMU가 내장되어 있습니다.



## Page Fault

가상 메모리 기법을 활용하면 필요한 페이지가 메모리에 없는(물리주소에 없는) page fault 가 발생하게 됩니다. 이 경우에 디스크에서 페이지를 불러오고 필요없는 페이지를 디스크로 보내는 Swap In/Out 작업을 하게 됩니다.



## Page Replacement

일단 위 Page fault로 인해서 디스크를 오가게 되는데 일단 이런 작업은 시간이 많이 들게 됩니다. 보조 기억장치는 일반적으로 메모리보다 느리기 때문입니다. 

이런 시간을 최대한 줄이기 위해서 사용 가능성이 높은 페이지는 메모리에, 가능성이 적은 페이지는 디스크에 두는 정책이 필요하게 됩니다.

- FIFO Page Replacement
  - 자료구조의 FIFO 처럼 선입선출, 가장 먼저 들어온 페이지를 교체해 줍니다.
  - 이 경우 [Belady's Anomaly](https://en.wikipedia.org/wiki/B%C3%A9l%C3%A1dy%27s_anomaly)이라는 문제가 생길 수 있다
    - 페이지의 프레임 수가 커질수록(사용 가능 메모리 크기가 커질때) Page Fault가 줄어드는걸 원하는데 역으로 늘어난다는 역설
    - 다른 Page Replacement 정책에는 없는 이야기입니다.
  - 간단한 만큼 그렇게 좋은 성능이 아닙니다.
- Optimal Page Replacement
  - **가장 오랫동안 사용하지 않을 페이지를 내보내는 알고리즘**입니다.
  - 왜 굳이 볼드체를 했냐면 이건 아주 이상적인 알고리즘이기 때문입니다. 미래를 볼 수 없어 어떤 페이지가 오랫동안 사용되지 않을지 알 수 없습니다.
  - 때문에 가장 시간이 짧으며 타 알고리즘의 성능 측정용으로 많이 사용됩니다.
- LRU (Least Recently Used)
  - 가장 오랫동안 사용하지 않은 페이지를 내보내는 알고리즘입니다.
  - 시간 기록을 위한 오버헤드가 있습니다
  - Second change page replacement algorithm (= colck algorithm)이란 방법이 추가적으로 있습니다.
    - 페이지별로 reference bit가 있어 0이면 안한것, 1이면 한 것입니다.
    - 시계방향으로 체크를 하면서 1일 경우 한턴을 넘기고 0으로 바꾼뒤 0이라면 이 페이지를 교체하는 방식입니다.

- LFU (Least Frequency Used)
  - 가장 적게 사용한걸 내보내는 알고리즘입니다.



## TLB (Translation Lookaside Buffer)

위 물리 주소에 페이지를 두는 것에 관련한 이야기라면 이건 **주소를 관리하는**이야기 입니다. 

TLB는 MMU 내부에 있으며, 실제 페이지 테이블 중 최근 값들을 저장하는 버퍼입니다. 최근에 사용되는 페이지들의 주소를 관리하면서 주소를 빨리 찾아갈 수 있게 하는 것입니다. 즉, MMU의 **주소 변환 작업을 줄여주는** 역할을 합니다.

주소를 찾기 위해서는 일단 TLB에 접근 한 다음 TLB에 있다면 이를 통해 바로 접근, 없다면 MMU에서 주소를 변환한 후 메모리에 접근하게 됩니다.
